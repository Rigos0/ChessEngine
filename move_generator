import numpy as np
from copy import deepcopy
from keras.models import load_model
# import keras
# improved version of move generator
# new features: generates arrays of attacked squares (useful for creating datasets)
#               generates arrays of 1s or -1s if king is in check
#               generates arrays for king safety and pins


class Generator:
    def __init__(self):
        self.squares = [27, 28, 29, 30, 31, 32, 33, 34,
                        39, 40, 41, 42, 43, 44, 45, 46,
                        51, 52, 53, 54, 55, 56, 57, 58,
                        63, 64, 65, 66, 67, 68, 69, 70,
                        75, 76, 77, 78, 79, 80, 81, 82,
                        87, 88, 89, 90, 91, 92, 93, 94,
                        99, 100, 101, 102, 103, 104, 105, 106,
                        111, 112, 113, 114, 115, 116, 117, 118]
        self.white_pieces = [[39, 40, 41, 42, 43, 44, 45, 46], [33, 28], [32, 29], [27, 34], [30], [31]]
        self.black_pieces = [[99, 100, 101, 102, 103, 104, 105, 106], [112, 117], [113, 116], [111, 118], [114], [115]]
        self.w_short_castle, self.w_long_castle = True, True
        self.b_short_castle, self.b_long_castle = True, True
        self.enpassant_square = []
        self.white_occupation, self.black_occupation = None, None
        self.my_pieces = None
        self.my_occupation = None
        self.enemy_occupation = None
        self.opponents_pieces = None
        self.short_castle = None
        self.long_castle = None
        self.up, self.down = None, None
        self.second_row, self.last_row, self.first_row = None, None, None

    # returns list of occupied
    @staticmethod
    def create_occupation_list(nested_list):
        occup_list = []
        for piece_type in nested_list:
            for piece_pos in piece_type:
                occup_list.append(piece_pos)
        return occup_list

    def return_current_position(self):
        current_position = {
            'white': self.white_pieces,
            'black': self.black_pieces,
            'w_short': self.w_short_castle,
            'w_long': self.w_long_castle,
            'b_short': self.b_short_castle,
            'b_long': self.b_long_castle,
            'enpassant': self.enpassant_square}
        return current_position

    def go_back_to_previous_position(self, previous_position, side_to_move):
        if side_to_move == 'white':
            self.white_pieces = self.my_pieces = previous_position.get('white')
            self.black_pieces = self.opponents_pieces = previous_position.get('black')
            self.w_short_castle  = previous_position.get('w_short')#= self.short_castle
            self.w_long_castle  = previous_position.get('w_long')#= self.long_castle
        else:
            self.white_pieces = self.opponents_pieces = previous_position.get('white')
            self.black_pieces = self.my_pieces = previous_position.get('black')
            self.b_short_castle = previous_position.get('b_short')#= self.short_castle
            self.b_long_castle = previous_position.get('b_long')#= self.long_castle
        self.enpassant_square = previous_position.get('enpassant')


    # return True if given square is on the board
    def on_board(self, square):
        if square not in self.squares:
            return False
        else:
            return True

    def set_up_attributes(self, side_to_move, create_occupation=True):
        # create a list of pieces that is not nested, so we don't have to loop over the nested lists
        if create_occupation:
            self.white_occupation = self.create_occupation_list(self.white_pieces)
            self.black_occupation = self.create_occupation_list(self.black_pieces)
        if side_to_move == "white":
            self.my_pieces = self.white_pieces
            self.my_occupation = self.white_occupation
            self.enemy_occupation = self.black_occupation
            self.opponents_pieces = self.black_pieces
            self.short_castle = self.w_short_castle
            self.long_castle = self.w_long_castle
            self.up, self.down = 12, -12
            self.second_row, self.last_row, self.first_row = self.squares[8:16], self.squares[56:64], self.squares[0:8]
        else:
            self.my_pieces = self.black_pieces
            self.my_occupation = self.black_occupation
            self.enemy_occupation = self.white_occupation
            self.opponents_pieces = self.white_pieces
            self.short_castle = self.b_short_castle
            self.long_castle = self.b_long_castle
            self.up, self.down = -12, 12
            self.second_row, self.last_row, self.first_row = self.squares[48:56], self.squares[0:8], self.squares[56:64]

    def generate_moves(self, side, generate_only="all", opponents_attacks=None):
        self.set_up_attributes(side)
        # skip sliding pieces if we are only generating other attacks
        if generate_only != "other_attacks":
            # generate diagonal moves
            for move in self.sliding_pieces("diagonal", generate_only):
                yield move
            # generate rook moves for rooks and queens
            for move in self.sliding_pieces("heavy", generate_only):
                yield move
            # if we want to generate only sliding pieces, cut the function here
            if generate_only == "only_sliding":
                return

        # generate pawn moves
        for i in self.my_pieces[0]:
            # pawns always attack squares diagonally in front of them
            # yield all attacked squares if generating attacks
            if generate_only == "other_attacks":
                if self.on_board(i + self.up + 1):
                    yield [i, i + self.up + 1]
                if self.on_board(i + self.up + -1):
                    yield [i, i + self.up + -1]
                continue
            # append taking if there is an enemy piece on taking square
            if (i + self.up + 1) in self.enemy_occupation or (i + self.up + 1) in self.enpassant_square:
                yield [i, i + self.up + 1]
            if (i + self.up + -1) in self.enemy_occupation or (i + self.up - 1) in self.enpassant_square:
                yield [i, i + self.up + -1]
            # move up
            # pawns do not attack squares in front of them, therefore we want to skip next few lines if we are
            # using this function to generate attacks
            if generate_only != "other_attacks":
                if (i + self.up) not in self.enemy_occupation and (i + self.up) not in self.my_occupation:
                    yield [i, i + self.up]
                    # double move if pawns on initial squares
                    if i in self.second_row:
                        if (i + self.up * 2) not in self.enemy_occupation and (
                                i + self.up * 2) not in self.my_occupation:
                            yield [i, i + self.up * 2]
        # generate knight moves
        for k in self.my_pieces[1]:
            directions = [25, -25, 23, -23, 14, -14, 10, -10]
            for dir in directions:
                next_square = k + dir
                if self.on_board(next_square):
                    # append even defended squares if argument generate_only is "other_attacks"
                    if generate_only == "other_attacks":
                        yield [k, next_square]
                        continue
                    # otherwise do not yield moves that would result in taking our own piece
                    if next_square not in self.my_occupation:
                        yield [k, next_square]
        # create king moves
        directions = [-11, -12, -13, -1, 1, 11, 12, 13]
        for direction in directions:
            next_square = self.my_pieces[5][0] + direction
            if self.on_board(next_square):
                # even kings do attack squares, this is useful especially to not allow kings attack each other
                if generate_only == "other_attacks":
                    yield [self.my_pieces[5][0], next_square]
                    continue
                # don't allow king to enter attacked squares
                if next_square not in opponents_attacks:
                    # don't allow the king to take its own pieces
                    if next_square not in self.my_occupation:
                        yield [self.my_pieces[5][0], next_square]
        # castling does not attack anything
        if generate_only == "all":
            # castling
            if self.short_castle:
                for move in self.castling(True, opponents_attacks):
                    yield move
            if self.long_castle:
                for move in self.castling(False, opponents_attacks):
                    yield move

    # get moves of bishops, queens, and rooks
    # pass argument "diagonal" to get diagonal moves, anything else to get rank and file moves
    # always pass lists of pieces for argument 2 and 3. 2 for current side to move, 3 for enemy side
    # use argument 4 to either generate possible moves or generate attacked squares
    # pass "only_sliding" to get attacks, anything else to get moves
    def sliding_pieces(self, piece_type, generate_only):
        if piece_type == "diagonal":
            slide_pieces = [self.my_pieces[2], self.my_pieces[4]]
            directions = [13, 11, -11, -13]
        else:
            slide_pieces = [self.my_pieces[3], self.my_pieces[4]]
            directions = [12, 1, -1, -12]
        # for both piece types
        for x in slide_pieces:
            # for every piece of current piece type
            for piece_pos in x:
                # for every direction
                for dir in directions:
                    # reset next square variable
                    next_square = piece_pos
                    # slide until not end of board or a piece in the way
                    while True:
                        next_square += dir
                        # check if next square on board
                        if not (self.on_board(next_square)):
                            break
                        # if our piece in way
                        if next_square in self.my_occupation:
                            # if we are generating attacks, then yield even our defended pieces
                            if generate_only == "only_sliding":
                                yield [piece_pos, next_square]
                            break
                        # if opponents piece in way
                        if next_square in self.enemy_occupation:
                            yield [piece_pos, next_square]
                            break
                        yield [piece_pos, next_square]

    # generates long or short castling moves
    def castling(self, short, opponents_attacks):
        if short:
            castle_occup_squares = [self.first_row[5], self.first_row[6]]
            castle_check_squares = [self.first_row[4], self.first_row[5], self.first_row[6]]
        else:
            castle_occup_squares = [self.first_row[3], self.first_row[2], self.first_row[1]]
            castle_check_squares = [self.first_row[4], self.first_row[3], self.first_row[2]]
        # check if are the castling squares occupied
        stop = False
        for i in castle_occup_squares:
            if i in self.my_occupation or (i in self.enemy_occupation):
                stop = True
                break
            # check if are castling squares attacked
            for x in castle_check_squares:
                if x in opponents_attacks:
                    stop = True
                    break
        if not stop:
            yield [self.my_pieces[5][0], castle_check_squares[-1]]

    def make_a_move(self, move, side_to_move):
        # play enpassant
        if self.enpassant_square:
            if move[0] in self.my_pieces[0] and move[1] in self.enpassant_square and move[1] - move[0] \
                    in [11, -11, 13, -13]:
                self.my_pieces[0][self.my_pieces[0].index(move[0])] = move[1]
                try:

                    self.opponents_pieces[0].remove(move[1] + self.down)
                except ValueError:
                    pass

        self.enpassant_square.clear()
        # detect castling
        if self.short_castle:
            # don't allow castling from now on if a rook or king is moved
            if move[0] == self.first_row[7] or move[0] == self.first_row[4]:
                if side_to_move == "white":
                    self.w_short_castle = False
                else:
                    self.b_short_castle = False
                self.short_castle = False
            if move == [self.first_row[4], self.first_row[6]] and move[0] in self.my_pieces[5]:
                # update king position
                self.my_pieces[5][0] = self.first_row[6]
                # update rook position
                self.my_pieces[3][self.my_pieces[3].index(self.first_row[7])] = self.first_row[5]
                return
        if self.long_castle:
            # don't allow castling from now on if a rook or king is moved
            if move[0] == self.first_row[0] or move[0] == self.first_row[4]:
                if side_to_move == "white":
                    self.w_long_castle = False
                else:
                    self.b_long_castle = False
                self.long_castle = False
            if move == [self.first_row[4], self.first_row[2]] and move[0] in self.my_pieces[5]:
                # update king position
                self.my_pieces[5][0] = self.first_row[2]
                # update rook position
                self.my_pieces[3][self.my_pieces[3].index(self.first_row[0])] = self.first_row[3]
                return

        # detect pawn double move
        if move[0] in self.my_pieces[0] and (15 < (move[1] - move[0]) or (move[1] - move[0]) < -15):
            self.enpassant_square.append(move[0] + 0.5 * (move[1] - move[0]))
        # replace old position of our piece with new one
        for x, y in enumerate(self.my_pieces):
            for index, position in enumerate(y):
                if position == move[0]:
                    self.my_pieces[x][index] = move[1]

        # promote a pawn
        for x in self.my_pieces[0]:
            if x in self.last_row:
                self.my_pieces[0].remove(x)
                self.my_pieces[4].append(x)

        # delete taken pieces
        for x, y in enumerate(self.opponents_pieces):
            for index, position in enumerate(y):
                if position == move[1]:
                    self.opponents_pieces[x].pop(index)

    def detect_check(self, enemy_attacks):
        if self.my_pieces[5][0] in enemy_attacks:
            return True

    def reset_board(self):
        self.white_pieces = [[39, 40, 41, 42, 43, 44, 45, 46], [33, 28], [32, 29], [27, 34], [30], [31]]
        self.black_pieces = [[99, 100, 101, 102, 103, 104, 105, 106], [112, 117], [113, 116], [111, 118], [114], [115]]
        self.w_short_castle, self.w_long_castle = True, True
        self.b_short_castle, self.b_long_castle = True, True
        self.enpassant_square = []


generator = Generator()


def create_moves(side_to_move, return_matrix=False, validate=True):
    if side_to_move == "white":
        enemy_side = "black"
    else:
        enemy_side = "white"
    moves = []
    sliding_attacks = []
    other_attacks = []
    defended_squares = []
    check = False
    # generate squares that are attacked by black sliding pieces
    for move in generator.generate_moves(enemy_side, generate_only="only_sliding"):
        sliding_attacks.append(move[-1])
    # generate squares that are attacked by every other black piece
    for move in generator.generate_moves(enemy_side, generate_only="other_attacks"):
        other_attacks.append(move[-1])
    # generate white defended squares (this is only for creating datasets:
    for move in generator.generate_moves(side_to_move, generate_only="other_attacks"):
        defended_squares.append(move[1])
    for move in generator.generate_moves(side_to_move, generate_only="only_sliding"):
        defended_squares.append(move[1])
    # generate all white moves
    for move in generator.generate_moves(side_to_move, opponents_attacks=sliding_attacks + other_attacks):
        moves.append(move)

    if not validate:
        return moves
    trial_attacks = []
    moves_to_be_deleted = []
    if generator.detect_check(other_attacks + sliding_attacks):
        check = True
        for move in moves:
            for x in validate_legality(side_to_move, enemy_side, move, trial_attacks):
                moves_to_be_deleted.append(x)
    else:
        # if we are not in check, then check for validate only pieces that are under attacks of sliding pieces
        for move in moves:
            if move[0] in sliding_attacks:
                for x in validate_legality(side_to_move, enemy_side, move, trial_attacks):
                    moves_to_be_deleted.append(x)

    moves = [x for x in moves if x not in moves_to_be_deleted]

    if return_matrix:
        # return convert_to_matrix(sliding_attacks+other_attacks, defended_squares, check)
        matrix = convert_to_matrix(sliding_attacks + other_attacks, defended_squares, check)
        return moves, matrix
    else:
        return moves


def validate_legality(side_to_move, enemy_side, move, trial_attacks):
    moves_to_be_deleted = []
    current_position = deepcopy(generator.return_current_position())

    generator.make_a_move(move, side_to_move)
    # generate squares that are attacked by black sliding pieces
    for attack in generator.generate_moves(enemy_side, generate_only="only_sliding"):
        trial_attacks.append(attack[1])
    for attack in generator.generate_moves(enemy_side, generate_only="other_attacks"):
        trial_attacks.append(attack[1])
    generator.set_up_attributes(side_to_move)
    if generator.detect_check(trial_attacks):
        moves_to_be_deleted.append(move)
    generator.go_back_to_previous_position(current_position, side_to_move)
    trial_attacks.clear()

    return moves_to_be_deleted

# get a matrix representation of current position
def convert_to_matrix(enemy_attacks=None, defended_squares=None, check=None):
    square_list = []
    board_list = []
    ranks = []
    ranks_list = [[111, 112, 113, 114, 115, 116, 117, 118],
                  [99, 100, 101, 102, 103, 104, 105, 106],
                  [87, 88, 89, 90, 91, 92, 93, 94],
                  [75, 76, 77, 78, 79, 80, 81, 82],
                  [63, 64, 65, 66, 67, 68, 69, 70],
                  [51, 52, 53, 54, 55, 56, 57, 58],
                  [39, 40, 41, 42, 43, 44, 45, 46],
                  [27, 28, 29, 30, 31, 32, 33, 34]]
    white_pieces = generator.white_pieces
    black_pieces = generator.black_pieces
    # *8
    for rank in ranks_list:
        # *8
        for square in rank:
            # *6
            for i in range(6):
                if square in white_pieces[i]:
                    square_list.append(1)
                else:
                    square_list.append(0)
                if square in black_pieces[i]:
                    square_list.append(-1)
                else:
                    square_list.append(0)
            # number_of_defences = defended_squares.count(square)
            # square_list.append(number_of_defences)
            # number_of_enemy_attacks = enemy_attacks.count(square)
            # square_list.append(number_of_enemy_attacks*-1)
            # if check:
            #     square_list.append(-1)
            # elif generator.black_pieces[5] in defended_squares:
            #     square_list.append(1)
            # else:
            #     square_list.append(0)

            square_array = np.asarray(square_list)
            ranks.append(square_array)
            square_list.clear()
        ranks_array = np.asarray(ranks)
        board_list.append(ranks_array)
        ranks.clear()

    board_array = np.asarray(board_list)
    return board_array

import random


def select_random_move(nested_list):
    random_number = random.randint(0, len(nested_list) - 1)
    return nested_list[random_number]


def speed_test():
    counter = 0
    while True:
        counter = play_random(counter)
        generator.reset_board()
        if counter > 50_000:
            pass


def play_random(counter):
    while True:
        moves = create_moves("white")
        if not moves:
            return counter
        random_move = select_random_move(moves)
        generator.make_a_move(random_move, "white")
        counter += 1

        moves = create_moves("black")
        if not moves:
            return counter
        random_move = select_random_move(moves)
        generator.make_a_move(random_move, "black")
        counter += 1

        if not (generator.white_pieces[0] or generator.white_pieces[1] or generator.white_pieces[2]
                or generator.white_pieces[3] or generator.white_pieces[4] or generator.black_pieces[0]
                or generator.black_pieces[1] or generator.black_pieces[2] or generator.black_pieces[3]
                or generator.black_pieces[4]):
            return counter


class Search:
    def __init__(self):
        # keras.backend.set_learning_phase(0)
        self.model = load_model('evaluation_regression2')
        self.hash_table = {}
        self.max_alpha = -100
        self.min_beta = 100
        self.steps = 0
        self.zero_ply_predictions =[]
        self.one_ply_prediction = []
        self.search_depth = 0

    def search(self, moves, side_to_move):
        predictions = []
        for move in moves:
            current_position = deepcopy(generator.return_current_position())
            generator.make_a_move(move, side_to_move)
            white_moves = create_moves("white", return_matrix=False)
            if not white_moves:
                return float(-50)
            prediction = self.white(white_moves, predictions)
            predictions.append(prediction)
            generator.go_back_to_previous_position(current_position, side_to_move)
        if not predictions:
            for i in range(5):
                print("mate")

        mini = min(predictions)
        index = predictions.index(mini)
        return moves[index]

    def white(self, moves, predictions_list):
        predictions = []
        for move in moves:
            current_position = deepcopy(generator.return_current_position())
            generator.make_a_move(move, "white")
            black_moves = create_moves("black", return_matrix=False)
            if not black_moves:
                return float(50)
            prediction = self.black(black_moves)
            predictions.append(prediction)
            generator.go_back_to_previous_position(current_position, "white")
            if predictions_list:
                if prediction > max(predictions_list):
                    return max(predictions)
        return max(predictions)

    def black(self, moves):
        predictions = []
        for move in moves:
            current_position = deepcopy(generator.return_current_position())
            generator.make_a_move(move, "black")

            position = convert_to_matrix()
            position_array = np.array([position])
            current_hash = hash_current_position()
            if current_hash not in self.hash_table.keys():
                prediction = self.model.predict(position_array)[0][0]
                prediction = float(prediction)
                self.hash_table[current_hash] = prediction
            else:
                prediction = self.hash_table.get(current_hash)
            predictions.append(prediction)
            generator.go_back_to_previous_position(current_position, "black")

        if not predictions:
            print("white in mate")
            return -100

        return min(predictions)

    def optipath_search(self):
        next_positions = []
        moves = create_moves('black', return_matrix=False)
        for move in moves:
            current_position = deepcopy(generator.return_current_position())
            generator.make_a_move(move, "black")
            next_positions.append(convert_to_matrix())
            generator.go_back_to_previous_position(current_position, "black")

        self.zero_ply_predictions = self.model.predict(np.asarray(next_positions))
        while True:
            # find current best move
            minimize_index = np.argmin(self.zero_ply_predictions)
            # play the move and call white
            current_position = deepcopy(generator.return_current_position())
            generator.make_a_move(moves[minimize_index], "black")

            self.steps += 1
            search_path_eval = self.optipath_white()
            self.zero_ply_predictions[minimize_index] = search_path_eval
            generator.go_back_to_previous_position(current_position, "black")
            if self.steps > 500:
                minimize = np.argmin(self.zero_ply_predictions)
                self.steps = 0
                self.zero_ply_predictions = []
                return moves[minimize]

    def optipath_white(self):
        next_positions = []
        moves = create_moves('white', return_matrix=False)
        if not moves:
            return np.array([-50])
        for move in moves:
            current_position = deepcopy(generator.return_current_position())
            generator.make_a_move(move, "white")
            next_positions.append(convert_to_matrix())
            generator.go_back_to_previous_position(current_position, "white")

        predictions = self.model.predict(np.asarray(next_positions))
        # find current best move
        maximize_index = np.argmax(predictions)
        # play the move and call white
        generator.make_a_move(moves[maximize_index], "white")
        self.steps += 1
        search_path_eval = self.optipath_black()
        return search_path_eval

    def optipath_black(self):
        next_positions = []
        moves = create_moves('black', return_matrix=False)
        if not moves:
            return np.array([50])
        for move in moves:
            current_position = deepcopy(generator.return_current_position())
            generator.make_a_move(move, "black")
            next_positions.append(convert_to_matrix())
            generator.go_back_to_previous_position(current_position, "black")

        predictions = self.model.predict(np.asarray(next_positions))
        # find current best move
        current_min = np.amin(predictions)
        self.search_depth += 1
        if current_min > np.amin(self.zero_ply_predictions) or self.steps > 500 or self.search_depth > 30:

            if current_min > np.amin(self.zero_ply_predictions):
                self.search_depth = 0
            return current_min

        minimize_index = np.argmin(predictions)
        # play the move and call white
        generator.make_a_move(moves[minimize_index], "white")
        self.steps += 1
        search_path_eval = self.optipath_white()
        return search_path_eval






def hash_current_position():
    list_of_tuples = []
    for i in generator.white_pieces:
        list_of_tuples.append(tuple(i))
    for x in generator.black_pieces:
        list_of_tuples.append(tuple(x))
    converted = tuple(list_of_tuples)
    return hash(converted)
